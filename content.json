{"pages":[],"posts":[{"title":"博客初心","text":"辅助记忆(记忆力差，看过的知识点用一次就容易忘。) 展示自己涉猎的知识，可用于面试。 分享一些自己对技术与生活的见解与看法。 记录自己的变化与成长。 很早就想写个人博客，用于记录学习笔记，但因为拖延症，强迫症迟迟没有开工。 直到2021年遇见了gitpage，一见钟情，属于自己的blog，可装插件扩展， 美化主题，甚至可自己编码个性化打造专属于自己的blog功能样式，逼格到位， 感觉像是获得了青龙偃月刀，忍不住想耍一耍。 并且这几年从个人，到城市，到生活，乃至世界都有很多事情发生，想谈谈自己 对这些变化的一些看法，主要是想将自己的思想曝露出来和其他人的碰撞一下， 相似的可以获得认同感，相悖的可以进行更进一步的思考。 因为是程序员，敲代码基本都是用半角英文符号，所以输入法就默认调成这 种设置了，码文的时候也全部默认英文半角符号，除了一些像是书名号《》 之类的符号，看的别扭的请轻喷。 写文章频率不定，暂定三种文章类型。 学习笔记 (参考的是其他人的blog，不成体系的，零碎的笔记。) 读书笔记 (看的书，然后记录一些笔记，会出多个文章，成一个系列。) 生活感悟 (生活中所闻所见，编成小段故事，有夸张成分，练笔用。) 学习笔记系列，可能会贴较多的原文参考链接，因为他们已经写的很好了，我仅 仅简单的做一下笔记，防止可能的链接失效，或是做一些补充笔记。 这里真的很 感谢互联网，有问题上某度上一搜，大部分都能得到解决，感谢那些对我解决问 题有帮助的文章博主。 读书笔记系列，一些书本可能是很久之前看的，可能有需要重新看一遍，才能记 录出有用的笔记，书本动辄百页，里面包含大量的论文引用，这里我的想法就是 不去做考查了，直接记结论，背公式，先信了再说，所以我会记录更多的结论和 公式，而不是推导的过程，推导的过程可能就是贴一些我认为解答的较好的链接。 计算机的书往往包含了大量的零碎的知识点，这里我不会将书中的内容照搬下来， 只会记一些对我有启发，我认为我尚未掌握的内容，那些零碎的知识就是忘记了 再快速查阅下资料，或是回这本书里快速找一下内容。 还有一些内容过于深奥， 暂时我不能掌握理解，我就做一些猜想和记录，不做强求了。 生活感悟这系列，我有较多想表达的东西，这是从个人视角出发的，想表达出自 己的主观想法，想了解我这个人的话，可以看看这个系列。 这个系列主要是受到 (笨木头与游戏开发，烟雨迷离半世殇)等博主文章的启发，当看到一些他们个人 的想法，我表示认同和感到共鸣的时候，就会有到原来我不是一个人啊这种想法。 不仅能从他们的技术文章能学到知识解决问题，那些细枝末节处，文笔较少的主观 态度反而能让我学到更多东西。 俗话说要学读书，先学做人。 看到他人积极向上的 人生态度，总是能从中感到振奋，受到鼓舞。 他们踩的坑无私的告知了我们，也让 我可以做出充足准备，从而提前做出规避，或是更妥善的解决这样那样的小问题。 不过呢，正经人谁写日记啊，写出来的哪能叫心里话，所以我会拽拽文笔，通过 第三视角，添油加醋的，隐晦的表达一些潜藏在心里的想法。","link":"/2022/03/13/a_intro/"},{"title":"《战神4》游玩感想 (一)","text":"战神的系列作品，第一次接触是在一个老外的PSP2000掌机上接触到的。","link":"/2022/03/17/game_GodOfWar4_01/"},{"title":"学习搭建Hexo+Github个人网站详细教程","text":"一.什么是Hexo? Hexo是一款基于Node.js的静态博客框架, 依赖少易于安装使用, 可以方便的生成静态网页托管在GitHub和Heroku上, 是搭建博客的首选框架. 二.Github创建个人仓库 登陆自己的Github账号, 点击GitHub中的New repository创建新仓库, 仓库名必须为: xxx.github.io(xxx使用你的Github账号名代替). 三.安装环境 ** 安装git https://git-scm.com/download/ ** 安装node.js http://nodejs.cn/download/ 四.使用Hexo 4.1 新建blog目录 例如xxx_blog, 进入该目录, 右键Git Bash. 4.2 安装Hexo 12345678//安装Hexo的基础框架npm i -g hexo//初始化Hexo框架hexo init//编译生成静态页面hexo g//启动本地服务hexo s 4.3 验证 启动浏览器, 访问 http://localhost:4000 即可预览你的blog. 五.发布Blog 5.1 设置git 12git config --global user.email &quot;userEail&quot;git config --global user.name &quot;userName&quot; 5.2 配置 _config.yml 文件 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 5.3 上传到Github上 123456// 清理目录hexo clean// 生成bloghexo g// 部署至你的Github上hexo d","link":"/2022/01/01/learn_hexo_blog/"},{"title":"实现 C# CoroutineManager","text":"因业务需求(moba游戏使用帧同步, 可使用协程书写技能的施法过程), 所以需要实现一个我们自己能掌控的协程管理器. 一.以下是源码 创建一个 CCoroutineManager.cs 脚本, 将以下脚本覆盖粘贴, 即可使用. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255using System;using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MyCoroutine{ public enum CoroutineState { Dead = 0, Ready, Running, Suspend, } internal class CCoroutine { private Stack&lt;IEnumerator&gt; m_stack = new Stack&lt;IEnumerator&gt;(); private CoroutineState m_eState = CoroutineState.Ready; private IEnumerator m_Curr = null; public int Id { get; private set; } public void Init(int id, IEnumerator root) { this.Id = id; this.m_stack.Clear(); this.m_stack.Push(root); this.m_Curr = root; this.m_eState = CoroutineState.Ready; } public void Tick() { if (this.m_eState == CoroutineState.Dead) return; if (this.m_eState == CoroutineState.Suspend) return; this.m_eState = CoroutineState.Running; // 递归遍历 RecursIteration(); if (this.m_stack.Count &gt; 0) return; this.m_eState = CoroutineState.Dead; } public CoroutineState GetState() { return this.m_eState; } private void RecursIteration() { while (this.m_stack.Count &gt; 0) { this.m_Curr = this.m_stack.Peek(); if (this.m_Curr.Current is CustomYieldInstruction yieldInstruction) { if (yieldInstruction.keepWaiting) { break; } } else if (this.m_Curr.Current is IEnumerator childIe) { this.m_stack.Push(childIe); continue; } // 子完成, 父步进 while (!this.m_Curr.MoveNext()) { this.m_stack.Pop(); if (this.m_stack.Count &lt;= 0) { break; } this.m_Curr = this.m_stack.Peek(); } } } public void Stop() { this.m_eState = CoroutineState.Dead; } public void Suspend() { if (this.m_eState == CoroutineState.Dead) return; this.m_eState = CoroutineState.Suspend; } public void Resume() { if (this.m_eState != CoroutineState.Suspend) return; this.m_eState = CoroutineState.Running; } public void Reset() { this.m_stack.Clear(); this.m_eState = CoroutineState.Dead; this.m_Curr = null; this.Id = 0; } } public sealed class CCoroutineManager { private Dictionary&lt;int, CCoroutine&gt; m_dicCoroutineMap = new Dictionary&lt;int, CCoroutine&gt;(); private List&lt;CCoroutine&gt; m_lstCoroutines = new List&lt;CCoroutine&gt;(); private static CCoroutineManager m_inst; public static CCoroutineManager instance =&gt; m_inst ?? (m_inst = new CCoroutineManager()); private static int CoroutineId = 0; #region 对象池 private int initSize; private Queue&lt;CCoroutine&gt; m_lstCoroutinePool = new Queue&lt;CCoroutine&gt;(); private void InitPool(int size) { this.initSize = size; while (m_lstCoroutinePool.Count &lt; size) { Recycle(new CCoroutine()); } } private CCoroutine Get() { CCoroutine cCoroutine = null; if (this.m_lstCoroutinePool.Count &gt; 0) { cCoroutine = this.m_lstCoroutinePool.Dequeue(); } else { cCoroutine = new CCoroutine(); } return cCoroutine; } private void Recycle(CCoroutine coroutine) { coroutine.Reset(); if (this.m_lstCoroutinePool.Count &gt;= this.initSize) return; this.m_lstCoroutinePool.Enqueue(coroutine); } #endregion public void Init() { CCoroutineManager.CoroutineId = 0; this.m_dicCoroutineMap.Clear(); this.m_lstCoroutines.Clear(); // 初始化对象池 InitPool(50); } public void Clear() { CCoroutineManager.CoroutineId = 0; this.m_dicCoroutineMap.Clear(); this.m_lstCoroutines.Clear(); this.m_lstCoroutinePool.Clear(); } public int StartCoroutine(IEnumerator enumerator) { ++CCoroutineManager.CoroutineId; var coroutine = this.Get(); coroutine.Init(CCoroutineManager.CoroutineId, enumerator); this.m_dicCoroutineMap.Add(CCoroutineManager.CoroutineId, coroutine); this.m_lstCoroutines.Add(coroutine); return CCoroutineManager.CoroutineId; } public void StopCoroutine(int eId) { if (!this.m_dicCoroutineMap.TryGetValue(eId, out var cCoroutine)) { Debug.LogWarning($&quot;CCoroutineManager.StopCoroutine Failed, not existent CoroutineId=[{eId}]&quot;); return; } cCoroutine.Stop(); } public void SuspendCoroutine(int eId) { if (!this.m_dicCoroutineMap.TryGetValue(eId, out var cCoroutine)) { Debug.LogWarning($&quot;CCoroutineManager.SuspendCoroutine Failed, not existent CoroutineId=[{eId}]&quot;); return; } cCoroutine.Suspend(); } public void ResumeCoroutine(int eId) { if (!this.m_dicCoroutineMap.TryGetValue(eId, out var cCoroutine)) { Debug.LogWarning($&quot;CCoroutineManager.ResumeCoroutine Failed, not existent CoroutineId=[{eId}]&quot;); return; } cCoroutine.Resume(); } public void Tick() { foreach (CCoroutine cCoroutine in this.m_lstCoroutines) { var state = cCoroutine.GetState(); if (state == CoroutineState.Dead || state == CoroutineState.Suspend) continue; cCoroutine.Tick(); } for (int i = this.m_lstCoroutines.Count - 1; i &gt;= 0; i--) { var coroutine = this.m_lstCoroutines[i]; if (coroutine.GetState() == CoroutineState.Dead) { this.m_dicCoroutineMap.Remove(coroutine.Id); this.m_lstCoroutines.RemoveAt(i); this.Recycle(coroutine); } } } }} CCoroutine类 采用 internal修饰, 使用CoroutineId作为参数, 是因为该类对象如果直接暴露, 则协程状态可被任意操纵(例如, 协程已经执行完毕, 却将其状态置为挂起, 则该对象将一直无法被回收). 可根据业务规模通过InitPool(capacity)该函数配置对象池的大小. 仿写Unity的 等待时间 和 等待完成. 1234567891011121314151617181920212223242526272829public class CustomWaitForSeconds : CustomYieldInstruction{ private float timer; public CustomWaitForSeconds(float waitTime) { timer = Time.time + waitTime; } public override bool keepWaiting { get { return Time.time &lt; timer; } }}public class CustomWaitUntil : CustomYieldInstruction{ private Func&lt;bool&gt; m_Predicate; public CustomWaitUntil(Func&lt;bool&gt; predicate) { this.m_Predicate = predicate; } public override bool keepWaiting { get { return m_Predicate != null &amp;&amp; !this.m_Predicate(); } }} 使用方式yield return new CustomWaitForSeconds(2f); 二.测试脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140using System;using UnityEngine;using MyCoroutine;using System.Collections;public class TestCoroutine : MonoBehaviour{ public bool LogEnabled; private int coroutineId; public static int CoroutineCount; private void Awake() { Debug.unityLogger.logEnabled = LogEnabled; } void Update() { Debug.Log($&quot;--------------Unity Update {CoroutineCount}-------------&quot;); CCoroutineManager.instance.Tick(); if (Input.GetKeyUp(KeyCode.H)) { Debug.Log(&quot;开始协程&quot;); coroutineId = CCoroutineManager.instance.StartCoroutine(TestAAAClass.AAA()); } if (Input.GetKeyUp(KeyCode.J)) { Debug.Log(&quot;挂起协程&quot;); CCoroutineManager.instance.SuspendCoroutine(coroutineId); } if (Input.GetKeyUp(KeyCode.K)) { Debug.Log(&quot;恢复协程&quot;); CCoroutineManager.instance.ResumeCoroutine(coroutineId); } if (Input.GetKeyUp(KeyCode.L)) { Debug.Log(&quot;暂停协程&quot;); CCoroutineManager.instance.StopCoroutine(coroutineId); } if (Input.GetKeyUp(KeyCode.G)) { Debug.Log(&quot;测试 CustomWaitUntil 功能&quot;); TestCCCClass.IsCCC = true; } }}public static class TestAAAClass{ public static IEnumerator AAA() { Debug.Log(&quot;开始协程AAA&quot;); yield return new CustomWaitForSeconds(1f); ++TestCoroutine.CoroutineCount; Debug.Log(&quot;开始协程AAA 1s后&quot;); yield return TestBBBClass.BBB(); ++TestCoroutine.CoroutineCount; yield return new CustomWaitForSeconds(2f); ++TestCoroutine.CoroutineCount; yield return TestCCCClass.CCC(); ++TestCoroutine.CoroutineCount; }}public static class TestBBBClass{ public static IEnumerator BBB() { Debug.Log(&quot;开始协程BBB&quot;); yield return new CustomWaitForSeconds(2f); Debug.Log(&quot;开始协程BBB 2s后&quot;); }}public static class TestCCCClass{ public static bool IsCCC = false; public static IEnumerator CCC() { Debug.Log(&quot;开始协程CCC&quot;); yield return new CustomWaitForSeconds(3f); ++TestCoroutine.CoroutineCount; Debug.Log(&quot;开始协程CCC 3s后&quot;); yield return TestDDDClass.DDD(); ++TestCoroutine.CoroutineCount; Debug.Log(&quot;开始等待 WaitUntil&quot;); yield return new CustomWaitUntil(() =&gt; IsCCC); ++TestCoroutine.CoroutineCount; Debug.Log(&quot;该协程所有逻辑结束&quot;); }}public static class TestDDDClass{ public static IEnumerator DDD() { Debug.Log(&quot;开始协程DDD&quot;); yield return new CustomWaitForSeconds(3f); Debug.Log(&quot;开始协程DDD 3s后&quot;); }}public class CustomWaitForSeconds : CustomYieldInstruction{ private float timer; public CustomWaitForSeconds(float waitTime) { timer = Time.time + waitTime; } public override bool keepWaiting { get { return Time.time &lt; timer; } }}public class CustomWaitUntil : CustomYieldInstruction{ private Func&lt;bool&gt; m_Predicate; public CustomWaitUntil(Func&lt;bool&gt; predicate) { this.m_Predicate = predicate; } public override bool keepWaiting { get { return m_Predicate != null &amp;&amp; !this.m_Predicate(); } }} 按下H键, 开始协程 按下J键, 挂起协程 按下K键, 恢复协程 按下L键, 暂停协程 按下G键, 测试 CustomWaitUntil 功能 测试Log 性能分析 三.心得 原本是想仿写Lua的协程, 不过Lua的协程是汇编层实现的完全不对称协程(其实就是还没看懂Lua的源码). 最后还是仿Unity实现了一个支持可在中途手动挂起(suspend), 手动恢复(resume)的协程管理器. 状态 MyCoroutine Lua Coroutine Unity Coroutine suspended 手动挂起时 创建时,yield 后 无 running 协程内打印时 协程内打印时 无 normal 创建时 协程A唤醒协程B时 无 dead 协程执行完毕 协程执行完毕 协程执行完毕 yield 仅迭代 挂起 仅迭代","link":"/2021/09/03/learn_coroutine/"},{"title":"实现Shader 技能指示器(穿墙体时透明)","text":"一.使用前 指示器被树遮挡 二.使用后 指示器被树遮挡部分呈半透明 三.理解使用 使用该Shader的Mesh先渲染时, 先走Pass#0通道, 只有遮罩该Mesh的部分渲染(ZTest Greater, 深度大于其深度的测试通过), 但关闭深度写入(ZWrite Off, 即该Mesh的深度此时仅进行测试, 不做记录), 其他模型的Mesh深度就无法覆盖它, 因测试通过已将颜色写入缓存区(写入时透明度×0.2, 该变量可曝露至面板上自行调节, 写入缓冲区的颜色将与其他颜色进行Blend混合). 然后走Pass#1通道, 该Mesh只有不被遮罩的部分渲染. (此处的ZWrite是否写入, 并不影响效果, 因为重要的深度测试已经在Pass#0时已经进行完毕) 项目中人物也会被遮挡, 也可使用该Shader实现被遮挡时高亮透明等效果, 效果可在Pass#0处自行拓展实现. 记录: 当一个角色有武器或者, 背包等装饰物时, 无法这样简单的使用该Shader, 因为其二者即使不被墙体遮挡, 它们两个也会互相遮挡, 导致显示错误.(暂没发现好的解决办法, 暂时记录持续跟踪.) 四.源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'Shader &quot;Custom/Indicator&quot; { Properties { _BaseColor(&quot;BaseColor&quot;, Color) = (1,1,1,1) _MainTex(&quot;Base 2D&quot;, 2D) = &quot;white&quot;{} } SubShader { Tags{ &quot;RenderType&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent+1&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;ForceNoShadowCasting&quot; = &quot;True&quot; } //渲染X光效果的Pass Pass { Blend SrcAlpha OneMinusSrcAlpha ZWrite Off ZTest Greater CGPROGRAM #include &quot;Lighting.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; uniform float4 _BaseColor; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD1; }; v2f vert (appdata_base v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed4 color = tex2D(_MainTex, i.uv); color.rgb = color.rgb * _BaseColor.rgb; color.a = color.a * _BaseColor.a; color.a *= 0.2; return color; } #pragma vertex vert #pragma fragment frag ENDCG } //正常渲染的Pass Pass { ZWrite On ZTest Less Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #include &quot;Lighting.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; uniform float4 _BaseColor; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD1; }; v2f vert(appdata_base v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed4 color = tex2D(_MainTex, i.uv); color.rgb = color.rgb * _BaseColor.rgb; color.a = color.a * _BaseColor.a; return color; } #pragma vertex vert #pragma fragment frag ENDCG } } FallBack &quot;Diffuse&quot; }","link":"/2022/03/08/learn_shader_01/"},{"title":"Markdown 语法学习","text":"一.标题 在想要设置为标题的文字前面加#来表示 一个#是一级标题, 二个#是二级标题, 以此类推. 支持六级标题. &gt; 注: 标准语法一般在#后跟个空格再写文字. 示例: 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下: 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二.字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例: 1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下: 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 三.引用 在引用的文字前加&gt;即可. 引用也可以嵌套, 如加两个&gt;&gt; 三个&gt;&gt;&gt; n个... 示例: 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下: 这是引用的内容 &gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 四.分割线 三个或者三个以上的-或者*都可以. (因笔者要书写LaTeX排版的数学公式, 已将hexo默认的渲染引擎改为pandoc, 经测试分割线只能使用一种---了) 示例: 1234------- // pandoc不支持三个的*** // pandoc不支持***** // pandoc不支持 效果如下: 五.图片 语法: 1234![图片alt](图片地址 ''图片titile'')图片alt即使显示在图片下面的文字, 相当于对图片内容的解释.图片title就是图片的标题, 当鼠标移到图片上时显示的内容. title可加可不加 示例: 1![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下: blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。 六.超链接 语法: 12[超链接名](超链接地址 &quot;超链接title&quot;)titile可加可不加 示例: 12[百度](http://baidu.com)[GitHub](http://gitHub.com) 效果如下: 百度 GitHub 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七.列表 无序列表 语法: 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法: 数字加点 123451. 列表内容2. 列表内容3. 列表内容注意: 序号跟内容之间要有空格 效果如下: 列表内容 列表内容 列表内容 列表嵌套 在下一级之前敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 八.表格 语法: 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例: 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九.代码 语法: 单行代码: 代码之间分别用一个反引号包起来 1`代码内容` 代码块: 代码之间分别用三个反引号包起来, 且两边的反引号单独占一行 123456```` function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun();```` 注: 为了防止转译, 多加了个`符号实际是没有的. 效果如下: 单行代码 代码内容 代码块 1234function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun(); 十.流程图 示例: 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 效果如下: flow st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp; 注: hexo 暂不支持流程图.","link":"/2021/08/10/learn_markdown/"},{"title":"机器学习笔记 第一周","text":"测试LaTex排版的方程显示 \\[ \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} \\]","link":"/2022/03/08/note_machine_learning_01/"},{"title":"读书笔记《Building a 2D Game Physics Engine》（二）","text":"第一章: 介绍2D游戏物理引擎 123var gEngine = gEngine || {};gEngine.Core = (function () {}()); 12345var mCanvas, mConntext, mWidth = 800, mHeight = 450;mCanvas = document.getElementById('canvas');mContext = mCanvas.getContext('2d');mCanvas.height = mHeight;mCanvas.width = mWidth; 123456var mPublic = { mWidth: mWidth, mHeight: mHeight, mContext: mContext};return mPublic; 第二章: 实现2D物理引擎核心 第三章: 合并碰撞检测 第四章: 完成物理引擎和刚体形状组件 第五章: 总结物理引擎","link":"/2021/08/14/note_building_a_2d_game_physics_engine2/"},{"title":"读书笔记《Building a 2D Game Physics Engine》（一）","text":"一.pdf书本网盘链接 链接：https://pan.baidu.com/s/1J5qSRKfQKQsMIgBMZYQb3w 提取码：fcr2 二.书上的成品展示 按↑↓键切换选择的物体. 按WASD键控制选择的物体上下左右移动. 按Q/E键控制选择的物体顺/逆时针旋转. 按IJKL键控制选择的物体的线性速度. 按U/O键控制选择的物体的角速度. 按Z/X键控制选择的物体的质量 按C/V键控制选择的物体的摩擦力 按B/N键控制选择的物体的弹性系数 按英文的逗号,键控制物理引擎运动是否启动 读书笔记《Building a 2D Game Physics Engine》 var Vec2 = function(x,y){ this.x = x; this.y = y; }; Vec2.prototype.length = function(){ return Math.sqrt(this.x * this.x + this.y * this.y); }; Vec2.prototype.add = function(vec){ return new Vec2(vec.x + this.x, vec.y + this.y); }; // a-b ===== b->a Vec2.prototype.subtract = function(vec){ return new Vec2(this.x - vec.x, this.y - vec.y); }; Vec2.prototype.scale = function(n){ return new Vec2(this.x * n, this.y * n); }; Vec2.prototype.dot = function(vec){ return (this.x * vec.x + this.y * vec.y); }; Vec2.prototype.cross = function(vec){ return (this.x * vec.y - this.y * vec.x); }; Vec2.prototype.rotate = function(center, angle){ // rotate in counterclockwise =>逆时针 var r = []; var x = this.x - center.x; var y = this.y - center.y; r[0] = x * Math.cos(angle) - y * Math.sin(angle); r[1] = x * Math.sin(angle) + y * Math.cos(angle); r[0] += center.x; r[1] += center.y; return new Vec2(r[0], r[1]); }; Vec2.prototype.normalize = function(){ var len = this.length(); if(len>0){ len = 1/len; } return new Vec2(this.x * len, this.y * len); }; Vec2.prototype.distance = function(vec){ var x = this.x - vec.x; var y = this.y - vec.y; return Math.sqrt(x * x + y * y); }; function MyGame(){ var width = gEngine.Core.mWidth; var height = gEngine.Core.mHeight; console.log(width); console.log(height); // var r1 = new Circle(new Vec2(width / 2, height / 2), // Math.random() * 10 + 20); var r1 = new Rectangle( new Vec2(width / 2, height / 2), 30, 60, 10, 1, 0); r1.mAcceleration = new Vec2(10, 0); var r2 = new Rectangle( new Vec2(width / 2, height / 2), 40, 20, 100, 1, 0); r2.mAcceleration = new Vec2(-5, 0); var up = new Rectangle(new Vec2(width / 2, 0), width, 3, 0, 1, 1); var down = new Rectangle(new Vec2(width / 2, height), width, 3, 0, 1, 1); var left = new Rectangle(new Vec2(0, height / 2), 3, height, 0, 1, 1); var right = new Rectangle(new Vec2(width, height / 2), 3, height, 0, 1, 1); } var gEngine = gEngine || {}; gEngine.Core = (function () { var mCanvas, mContext, mWidth = 650, mHeight = 650; mCanvas = document.getElementById('canvas'); mContext = mCanvas.getContext('2d'); mCanvas.height = mHeight; mCanvas.width = mWidth; var mAllObjects = []; var mGravity = new Vec2(0,10); var mMovement = false; var mCurrentTime, mElapsedTime, mPreviousTime = Date.now(), mLagTime = 0; var kFPS = 60; // Frames per second var kFrameTime = 1 / kFPS; var mUpdateIntervalInSeconds = kFrameTime; var kMPF = 1000 * kFrameTime; // Milliseconds per frame. var runGameLoop = function () { requestAnimationFrame(function () { runGameLoop(); }); // compute how much time has elapsed since the last RunLoop mCurrentTime = Date.now(); mElapsedTime = mCurrentTime - mPreviousTime; mPreviousTime = mCurrentTime; mLagTime += mElapsedTime; // Update the game the appropriate number of times. // Update only every Milliseconds per frame. // If lag larger then update frames, update until caught up. mContext.clearRect(0, 0, mWidth, mHeight); while(mLagTime >= kMPF){ mLagTime -= kMPF; gEngine.Physics.collision(); update(); } updateUIEcho(); draw(); }; var update = function () { var i; for (i = 0; i < mAllObjects.length; i++) { mAllObjects[i].update(mContext); } }; var updateUIEcho = function () { document.getElementById(\"uiEchoString\").innerHTML = \"Selected Object::\" + \"\" + \"Id: \" + gObjectNum + \"\" + \"Center: \" + mAllObjects[gObjectNum].mCenter.x.toPrecision(3) + \",\" + mAllObjects[gObjectNum].mCenter.y.toPrecision(3) + \"\" + \"Angle: \" + mAllObjects[gObjectNum].mAngle.toPrecision(3) + \"\" + \"Velocity: \" + mAllObjects[gObjectNum].mVelocity.x.toPrecision(3) + \",\" + mAllObjects[gObjectNum].mVelocity.y.toPrecision(3) + \"\" + \"AngluarVelocity: \" + mAllObjects[gObjectNum].mAngularVelocity. toPrecision(3) + \"\" + \"Mass: \" + 1 / mAllObjects[gObjectNum].mInvMass.toPrecision(3) + \"\" + \"Friction: \" + mAllObjects[gObjectNum].mFriction.toPrecision(3) + \"\" + \"Restitution: \" + mAllObjects[gObjectNum].mRestitution. toPrecision(3) + \"\" + \"Movement: \" + gEngine.Core.mMovement + \"\" + \" \" + \"Control: of selected object\" + \"\" + \"Num or Up/Down Arrow: Select Object\" + \"WASD + QE: Position [Move + Rotate]\" + \"IJKL + UO: Velocities [Linear + Angular]\" + \"Z/X: Mass [Decrease/Increase]\" + \"C/V: Frictrion [Decrease/Increase]\" + \"B/N: Restitution [Decrease/Increase]\" + \",: Movement [On/Off]\" + \" \" + \"F/G: Spawn [Rectangle/Circle] at selected object\" + \"H: Excite all objects\" + \"R: Reset System\" + \"\"; }; var draw = function () { // console.log(\"gObjectNum = \" + gObjectNum); // console.log(\"mAllObjects = \"+ mAllObjects.length); // mContext.clearRect(0, 0, mWidth, mHeight); var i; for (i = 0; i < mAllObjects.length; i++) { mContext.strokeStyle = 'blue'; if (i === gObjectNum) { mContext.strokeStyle = 'red'; } mAllObjects[i].draw(mContext); } }; var initializeEngineCore = function () { runGameLoop(); }; var mPublic = { initializeEngineCore: initializeEngineCore, mAllObjects: mAllObjects, mWidth: mWidth, mHeight: mHeight, mContext: mContext, mGravity: mGravity, mUpdateIntervalInSeconds: mUpdateIntervalInSeconds, mMovement: mMovement }; return mPublic; }()); gEngine.Physics = (function () { var mPositionalCorrectionFlag = true; // number of relaxation iteration var mRelaxationCount = 15; // percentage of separation to project objects var mPosCorrectionRate = 0.8; var drawCollisionInfo = function (collisionInfo, context) { context.beginPath(); context.moveTo(collisionInfo.mStart.x, collisionInfo.mStart.y); context.lineTo(collisionInfo.mEnd.x, collisionInfo.mEnd.y); context.closePath(); context.strokeStyle = \"red\"; context.stroke(); }; var collision = function () { var i, j, k; var collisionInfo = new CollisionInfo(); for (k = 0; k < mRelaxationCount; k++) { for (i = 0; i < gEngine.Core.mAllObjects.length; i++) { for (j = 0; j < gEngine.Core.mAllObjects.length; j++) { if (i === j) { continue; } if (gEngine.Core.mAllObjects[i].boundTest(gEngine.Core.mAllObjects[j])) { if (gEngine.Core.mAllObjects[i].collisionTest(gEngine.Core.mAllObjects[j], collisionInfo)) { if (collisionInfo.getNormal().dot( gEngine.Core.mAllObjects[j].mCenter.subtract( gEngine.Core.mAllObjects[i].mCenter)) < 0) { // collisionInfo.changeDir(); } // draw collision info (a black line that shows normal) drawCollisionInfo(collisionInfo, gEngine.Core.mContext); resolveCollision(gEngine.Core.mAllObjects[i], gEngine.Core.mAllObjects[j], collisionInfo); } gEngine.Core.mContext.strokeStyle = 'green'; gEngine.Core.mAllObjects[i].draw(gEngine.Core.mContext); gEngine.Core.mAllObjects[j].draw(gEngine.Core.mContext); } } } } }; var positionalCorrection = function (s1, s2, collisionInfo){ var s1InvMass = s1.mInvMass; var s2InvMass = s2.mInvMass; var num = collisionInfo.getDepth() / (s1InvMass + s2InvMass) * mPosCorrectionRate; var correctionAmount = collisionInfo.getNormal().scale(num); s1.move(correctionAmount.scale(-s1InvMass)); s2.move(correctionAmount.scale(s2InvMass)); }; var resolveCollision = function (s1, s2, collisionInfo){ if ((s1.mInvMass === 0) && (s2.mInvMass === 0)) { return; } // correct positions if (gEngine.Physics.mPositionalCorrectionFlag) { positionalCorrection(s1, s2, collisionInfo); } var n = collisionInfo.getNormal(); var start = collisionInfo.mStart.scale(s2.mInvMass / (s1.mInvMass + s2.mInvMass)); var end = collisionInfo.mEnd.scale(s1.mInvMass / (s1.mInvMass + s2.mInvMass)); var p = start.add(end); // r is vector form center of shape to collision point var r1 = p.subtract(s1.mCenter); var r2 = p.subtract(s2.mCenter); // newV = V + mAngularVelocity cross R var v1 = s1.mVelocity.add(new Vec2(-1 * s1.mAngularVelocity * r1.y, s1.mAngularVelocity * r1.x)); var v2 = s2.mVelocity.add(new Vec2(-1 * s2.mAngularVelocity * r2.y, s2.mAngularVelocity * r2.x)); var relativeVelocity = v2.subtract(v1); // Relative velocity in normal direction var rVelocityInNormal = relativeVelocity.dot(n); // if objects moving apart ignore if (rVelocityInNormal > 0) { return; } // R cross N var R1crossN = r1.cross(n); var R2crossN = r2.cross(n); // compute and apply response impulses for each object var newRestitution = Math.min(s1.mRestitution, s2.mRestitution); var newFriction = Math.min(s1.mFriction, s2.mFriction); // Calc impulse scalar // Reference: http://www.myphysicslab.com/collision.html var jN = -(1 + newRestitution) * rVelocityInNormal; jN = jN / (s1.mInvMass + s2.mInvMass + R1crossN * R1crossN * s1.mInertia + R2crossN * R2crossN * s2.mInertia); // impulse is in direction of normal ( from s1 to s2) var impulse = n.scale(jN); // impulse = F dt = m * deltaV // deltaV = impulse / m s1.mVelocity = s1.mVelocity.subtract(impulse.scale(s1.mInvMass)); s2.mVelocity = s2.mVelocity.add(impulse.scale(s2.mInvMass)); s1.mAngularVelocity -= R1crossN * jN * s1.mInertia; s2.mAngularVelocity += R2crossN * jN * s2.mInertia; // impulse is in direction of tangent var tangent = relativeVelocity.subtract(n.scale(relativeVelocity.dot(n))); // relativeVelocity.dot(tangent) should less than 0 tangent = tangent.normalize().scale(-1); var R1crossT = r1.cross(tangent); var R2crossT = r2.cross(tangent); var jT = -(1 + newRestitution) * relativeVelocity.dot(tangent) * newFriction; jT = jT / (s1.mInvMass + s2.mInvMass + R1crossT * R1crossT * s1.mInertia + R2crossT * R2crossT * s2.mInertia); // friction should be less than force in normal direction if (jT > jN) jT = jN; // impulse is form s1 to s2 (in opposite direction of velocity impulse = tangent.scale(jT); s1.mVelocity = s1.mVelocity.subtract(impulse.scale(s1.mInvMass)); s2.mVelocity = s2.mVelocity.add(impulse.scale(s2.mInvMass)); s1.mAngularVelocity -= R1crossT * jT * s1.mInertia; s2.mAngularVelocity -= R2crossT * jT * s2.mInertia; }; var mPublic = { collision: collision, mPositionalCorrectionFlag: mPositionalCorrectionFlag }; return mPublic; }()); var gObjectNum = 0; function userControl(event){ var keycode; var width = gEngine.Core.mWidth; var height = gEngine.Core.mHeight; var context = gEngine.Core.mContext; if(window.event){ // IE keycode = event.keyCode; } else if(event.which){ // Netscape/Firefox/Opera keycode = event.which; } if(keycode === 70){ //f var r1 = new Rectangle( new Vec2(gEngine.Core.mAllObjects[gObjectNum].mCenter.x, gEngine.Core.mAllObjects[gObjectNum].mCenter.y), Math.random() * 30 + 10, Math.random() * 30 + 10, Math.random() * 30, Math.random(), Math.random()); } if(keycode === 71){ //g var r1 = new Circle( new Vec2(gEngine.Core.mAllObjects[gObjectNum].mCenter.x, gEngine.Core.mAllObjects[gObjectNum].mCenter.y), Math.random() * 10 + 20, Math.random() * 30, Math.random(), Math.random()); } if (keycode === 72) { //H var i; for (i = 0; i < gEngine.Core.mAllObjects.length; i++) { if (gEngine.Core.mAllObjects[i].mInvMass !== 0) { gEngine.Core.mAllObjects[i].mVelocity = new Vec2(Math.random() * 20 - 10, Math.random() * 20 - 10); } } } if (keycode >= 48 && keycode","link":"/2021/08/10/note_building_a_2d_game_physics_engine1/"},{"title":"笔记之TCP详解","text":"一.原文连接 面试必备！TCP协议经典十五连问 告别TCP 二.笔记 TCP协议经典十五连问! 讲下TCP三次握手流程 TCP握手为什么不能是两次? 不能是四次? 讲下TCP四次挥手过程 TCP挥手为什么需要四次? TIME-WAIT状态为什么需要等待2MSL? TCP和UDP的区别 TCP报文首部有哪些字段, 说说器作用 TCP是如何保证可靠性的 TCP重传机制 TCP的滑动窗口 聊聊TCP的流量控制 TCP拥塞机制 半连接队列和SYN Flood攻击的关系 Nagle算法与延迟确认 TCP的粘包与拆包 TCP 基本认识 TCP头格式 为什么需要TCP协议? TCP工作在哪一层? 什么是TCP? 什么是TCP连接? 如何唯一确定一个TCP连接呢? 有一个IP的服务器监听了一个端口, 它的TCP的最大连接数是多少呢? Udp和TCP有什么区别呢? 分别的应用场景是? 为什么Udp头部没有首部长度字段, 而TCP头部有首部长度字段呢? 为什么Udp头部有包长度字段, 而TCP头部则没有包长度字段呢? TCP连接建立 TCP三次握手过程和状态变迁 如何在Linux系统中查看TCP状态？ 为什么是三次握手？不是两次、四次？ 为什么每次建立TCP连接时， 初始化的序列号都要求不一样呢？ 初始序列号ISN是如何随机产生的？ 既然IP层会分片, 为什么TCP层还需要MSS呢? 第一次握手丢失了, 会发生什么? 第二次握手丢失了, 会发生什么? 第三次握手丢失了, 会发生什么? 什么是SYN攻击? 如何避免SYN攻击? TCP连接断开 TCP四次挥手过程和状态变迁 为什么挥手需要四次? 第一次挥手丢失了, 会发生什么? 第二次挥手丢失了, 会发生什么? 第三次挥手丢失了, 会发生什么? 第四次挥手丢失了, 会发生什么? 为什么TIME_WAIT等待的时间是2MSL? 为什么需要TIME_WAIT状态? TIME_WAIT过多有什么危害? 如何优化TIME_WAIT? 如果已经建立了连接, 但是客户端突然出现故障了怎么半? 如果已经建立了连接, 但是客户端的进程崩溃了会发生什么?","link":"/2022/03/10/note_tcp/"},{"title":"《三五七言&#x2F;咏蚊词》","text":"1234567 《三五七言/咏蚊词》春草青，蚊子叮。穷白生形秽，扑扇羡流萤。前程好事思忧忖，柔荑皓腕亦啾鸣。言我相思乱，然我相思无。猜相思兮猜相忆，直相思兮自作情。惊避冷挥夺命手，犹聆轻齿普信蚊。","link":"/2022/03/20/poetry_001/"},{"title":"《春时》","text":"12345 《春时》榕都迢迢，聘婷皎皎，人是故乡亲。两城飞鸟难共趣，一心佳人教何寻。绿染芭蕉，红抹樱桃，恐又韶华逝。不言谁会凭阑意，只语难诉连理心。","link":"/2022/03/20/poetry_002/"}],"tags":[{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"Game","slug":"Game","link":"/tags/Game/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Shader","slug":"Shader","link":"/tags/Shader/"},{"name":"Machinelearning","slug":"Machinelearning","link":"/tags/Machinelearning/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"Poetry","slug":"Poetry","link":"/tags/Poetry/"}],"categories":[{"name":"游戏感想","slug":"游戏感想","link":"/categories/%E6%B8%B8%E6%88%8F%E6%84%9F%E6%83%B3/"},{"name":"搭建Blog","slug":"搭建Blog","link":"/categories/%E6%90%AD%E5%BB%BABlog/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"Shader","slug":"Shader","link":"/categories/Shader/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"诗词","slug":"诗词","link":"/categories/%E8%AF%97%E8%AF%8D/"}]}